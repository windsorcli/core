version: '3'

tasks:
  dashboards:
    desc: Download and patch vendored assets from source.yaml files
    silent: true
    cmds:
      - cmd: |
          # Find all source.yaml files in the repo
          find . -name 'source.yaml' -type f | while read source_file; do
            vendor_dir="$(dirname "$source_file")/"
            
            echo "Processing ${vendor_dir#./}..."
            
            # Parse upstream base URL
            base_url=$(grep '^[[:space:]]*url:' "$source_file" | head -1 | awk '{print $2}')
            [ -n "$base_url" ] && echo "  Upstream: $base_url"
            
            # Parse files and process each (export base_url for subshell)
            export base_url vendor_dir
            awk 'BEGIN { OFS="|" }
              /^[[:space:]]+-[[:space:]]+name:/ { 
                if (name) print name, (url ? url : "-"), (patch ? patch : "-")
                name=$NF; url=""; patch=""
              }
              /^[[:space:]]+url:/ { url=$2 }
              /^[[:space:]]+patch:/ { patch=$2 }
              END { if (name) print name, (url ? url : "-"), (patch ? patch : "-") }
            ' "$source_file" | while IFS='|' read file url patch; do
              [ "$url" = "-" ] && url=""
              [ "$patch" = "-" ] && patch=""
              [ -z "$file" ] && continue
              output="${vendor_dir}${file}"
              
              # Use explicit URL or construct from base
              if [ -n "$url" ]; then
                fetch_url="$url"
              elif [ -n "$base_url" ]; then
                fetch_url="${base_url}/${file}"
              else
                echo "  ERROR: No URL for $file"
                continue
              fi
              
              echo "  Fetching $file..."
              upstream=$(curl -sL "$fetch_url")
              
              if [ -n "$patch" ] && [ -f "${vendor_dir}${patch}" ]; then
                echo "  Applying ${patch}..."
                echo "$upstream" | jq --argjson ops "$(cat "${vendor_dir}${patch}")" '
                  reduce $ops[] as $op (.;
                    ($op.path | split("/") | .[1:] | map(if test("^[0-9]+$") then tonumber else . end)) as $path |
                    if $op.op == "replace" then setpath($path; $op.value)
                    elif $op.op == "add" then setpath($path; $op.value)
                    elif $op.op == "remove" then delpaths([$path])
                    else .
                    end
                  )
                ' > "$output"
              else
                echo "$upstream" > "$output"
              fi
              
              # Escape Grafana variables to prevent Flux substitution
              # $${var} becomes ${var} after Flux processing
              sed -i '' 's/\${\([^}]*\)}/$\${\1}/g' "$output" 2>/dev/null || \
              sed -i 's/\${\([^}]*\)}/$\${\1}/g' "$output"
            done
          done
          echo "Done."

  dashboards:lint:
    desc: Validate vendored JSON files and patch integrity
    silent: true
    cmds:
      - cmd: |
          ERRORS=0
          
          # Find all source.yaml files in the repo
          find . -name 'source.yaml' -type f | while read source_file; do
            vendor_dir="$(dirname "$source_file")/"
            
            echo "Validating ${vendor_dir#./}..."
            
            # Check all JSON files are valid
            for json_file in "$vendor_dir"*.json; do
              [ -f "$json_file" ] || continue
              filename=$(basename "$json_file")
              if ! jq empty "$json_file" 2>/dev/null; then
                echo "  ERROR: Invalid JSON in $filename"
                ERRORS=$((ERRORS + 1))
              else
                echo "  ✓ $filename: valid JSON"
              fi
            done
            
            # Check all patch files are valid JSON arrays
            for patch_file in "$vendor_dir"patches/*.patch.json; do
              [ -f "$patch_file" ] || continue
              filename=$(basename "$patch_file")
              if ! jq -e 'type == "array"' "$patch_file" >/dev/null 2>&1; then
                echo "  ERROR: Patch must be JSON array: $filename"
                ERRORS=$((ERRORS + 1))
              else
                ops=$(jq 'length' "$patch_file")
                echo "  ✓ $filename: $ops operations"
              fi
            done
          done
          
          if [ $ERRORS -gt 0 ]; then
            echo "Validation failed with $ERRORS errors"
            exit 1
          fi
          echo "All dashboards validated successfully"

  scan:
    desc: Scan for security vulnerabilities
    silent: true
    cmds:
      - cmd: source .venv/bin/activate && checkov -d {{.CLI_ARGS | default "terraform/"}} 2>/dev/null

  test:
    desc: Run Terraform tests (all or specific module)
    silent: true
    cmds:
      - cmd: |
          MODULE={{.CLI_ARGS | default "terraform"}}
          if [ -d "$MODULE" ]; then
            # Create a temporary directory for test results
            TEMP_DIR=$(mktemp -d)
            # Find all test files and run them in parallel
            find "$MODULE" -type f -name '*.tftest.hcl' | while read testfile; do
              testdir=$(dirname "$testfile")
              (
                cd "$testdir" && \
                echo "Running tests in $testdir..." && \
                terraform init -input=false -reconfigure && \
                OUTPUT=$(terraform test -no-color 2>&1)
                TEST_EXIT=$?
                echo "$OUTPUT"
                if [ $TEST_EXIT -ne 0 ]; then
                  echo "FAILED: $testfile" >> "$TEMP_DIR/failures"
                fi
                # Check for warnings (case-insensitive)
                if echo "$OUTPUT" | grep -qi "Warning:"; then
                  echo "WARNINGS: $testfile" >> "$TEMP_DIR/warnings"
                fi
              ) &
            done
            # Wait for all background jobs to complete
            wait
            # Check if any tests failed
            if [ -f "$TEMP_DIR/failures" ]; then
              echo "Test failures:"
              cat "$TEMP_DIR/failures"
              rm -rf "$TEMP_DIR"
              exit 1
            fi
            # Check if any warnings were found
            if [ -f "$TEMP_DIR/warnings" ]; then
              echo "Tests completed with warnings:"
              cat "$TEMP_DIR/warnings"
              rm -rf "$TEMP_DIR"
              exit 1
            fi
            rm -rf "$TEMP_DIR"
          else
            echo "Module path '$MODULE' does not exist."
            exit 1
          fi

  fmt:
    desc: Check Terraform formatting
    silent: true
    cmds:
      - cmd: terraform fmt -recursive

  docs:
    desc: Generate Terraform documentation
    silent: true
    cmds:
      - cmd: |
          find terraform -type d -exec test -e '{}/main.tf' -a -e '{}/variables.tf' \; -print | while read -r dir; do
            if [[ "$dir" == *"/modules/"* ]]; then
              continue
            fi
            echo "Generating docs for $dir"
            docker run --rm -v "$(pwd):/src" -w "/src/$dir" quay.io/terraform-docs/terraform-docs:0.20.0 markdown table --output-file README.md --output-mode inject .
          done
