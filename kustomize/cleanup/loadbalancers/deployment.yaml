---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: loadbalancer-cleanup
  namespace: system-cleanup
spec:
  replicas: 1
  progressDeadlineSeconds: 900
  selector:
    matchLabels:
      app: loadbalancer-cleanup
  template:
    metadata:
      labels:
        app: loadbalancer-cleanup
    spec:
      serviceAccountName: loadbalancer-cleanup
      volumes:
        - name: completion
          emptyDir: {}
      initContainers:
        - name: cleanup
          # renovate: datasource=docker depName=kubectl package=alpine/k8s
          image: alpine/k8s:1.35.0@sha256:18bc02c1e0df04451f4f9194eb7b7341c1165da5495459b52f85f72fb9545032
          env:
            - name: RESOURCE_WAIT_TIMEOUT
              value: "300"
            - name: RESOURCE_CHECK_INTERVAL
              value: "10"
            - name: AUTH_WAIT_TIMEOUT
              value: "600"
            - name: AUTH_CHECK_INTERVAL
              value: "5"
          resources:
            limits:
              cpu: "100m"
              memory: "64Mi"
            requests:
              cpu: "50m"
              memory: "32Mi"
          volumeMounts:
            - name: completion
              mountPath: /tmp/cleanup
          command:
            - /bin/sh
            - -c
            - |
              set -e

              # Wait for authorization semaphore (cleanup-authorized ConfigMap)
              echo "Waiting for cleanup-authorized ConfigMap..."
              elapsed=0
              while [ "$$elapsed" -lt "$$AUTH_WAIT_TIMEOUT" ]; do
                if kubectl get configmap cleanup-authorized -n system-cleanup >/dev/null 2>&1; then
                  echo "Authorization semaphore detected. Proceeding with cleanup..."
                  break
                fi
                echo "Waiting for authorization... ($${elapsed}s/$${AUTH_WAIT_TIMEOUT}s)"
                sleep "$$AUTH_CHECK_INTERVAL"
                elapsed=$$((elapsed + AUTH_CHECK_INTERVAL))
              done

              if ! kubectl get configmap cleanup-authorized -n system-cleanup >/dev/null 2>&1; then
                echo "ERROR: Timed out waiting for cleanup-authorized ConfigMap."
                echo "Cleanup aborted for safety."
                exit 1
              fi

              echo "Processing LoadBalancer Services..."
              kubectl get services --all-namespaces -o jsonpath='{range .items[?(@.spec.type=="LoadBalancer")]}{.metadata.namespace}/{.metadata.name}{"\n"}{end}' || true

              # Delete all LoadBalancer Services across all namespaces (non-blocking)
              echo "Deleting all LoadBalancer Services..."
              for ns in $$(kubectl get namespaces -o jsonpath='{.items[*].metadata.name}'); do
                kubectl delete services -n "$$ns" --field-selector spec.type=LoadBalancer --wait=false 2>/dev/null || true
              done

              # Wait for LoadBalancer Services to be deleted
              # We preserve all finalizers and let cloud controllers handle cleanup
              echo "Waiting for LoadBalancer Services to be deleted..."
              elapsed=0
              while [ "$$elapsed" -lt "$$RESOURCE_WAIT_TIMEOUT" ]; do
                remaining=$$(kubectl get services --all-namespaces -o json | jq '[.items[] | select(.spec.type == "LoadBalancer")] | length')
                if [ "$$remaining" -eq 0 ]; then
                  echo "All LoadBalancer Services deleted"
                  break
                fi

                # Log stuck Services but don't force-remove finalizers
                # Cloud controllers need to clean up their load balancers
                for svc in $$(kubectl get services --all-namespaces -o json | jq -r '.items[] | select(.spec.type == "LoadBalancer" and .metadata.deletionTimestamp != null) | "\(.metadata.namespace)/\(.metadata.name)"'); do
                  ns=$$(echo "$$svc" | cut -d'/' -f1)
                  name=$$(echo "$$svc" | cut -d'/' -f2)
                  echo "Service $$ns/$$name waiting for controller cleanup..."
                done

                echo "Still waiting for $$remaining LoadBalancer Services to be deleted..."
                sleep "$$RESOURCE_CHECK_INTERVAL"
                elapsed=$$((elapsed + RESOURCE_CHECK_INTERVAL))
              done

              # Final verification
              echo "Verifying cleanup..."
              remaining=$$(kubectl get services --all-namespaces -o json | jq '[.items[] | select(.spec.type == "LoadBalancer")] | length')
              if [ "$$remaining" -gt 0 ]; then
                echo "WARNING: Cleanup incomplete - $$remaining LoadBalancer Services remaining"
                echo "Controllers may still be processing. Remaining services:"
                kubectl get services --all-namespaces --field-selector spec.type=LoadBalancer 2>/dev/null || true
              fi
              echo "LoadBalancer cleanup completed"
              touch /tmp/cleanup/success
      containers:
        - name: status
          # renovate: datasource=docker depName=alpine package=alpine
          image: alpine:3.23.2@sha256:865b95f46d98cf867a156fe4a135ad3fe50d2056aa3f25ed31662dff6da4eb62
          resources:
            limits:
              cpu: "10m"
              memory: "16Mi"
            requests:
              cpu: "10m"
              memory: "16Mi"
          volumeMounts:
            - name: completion
              mountPath: /tmp/cleanup
          command:
            - /bin/sh
            - -c
            - |
              if [ ! -f /tmp/cleanup/success ]; then
                exit 1
              fi
              sleep infinity
