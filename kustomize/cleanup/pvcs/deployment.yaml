---
apiVersion: batch/v1
kind: Job
metadata:
  name: pvc-cleanup
  namespace: system-cleanup
spec:
  backoffLimit: 3
  ttlSecondsAfterFinished: 300
  template:
    metadata:
      labels:
        app: pvc-cleanup
    spec:
      restartPolicy: OnFailure
      serviceAccountName: pvc-cleanup
      containers:
        - name: cleanup
          # renovate: datasource=docker depName=kubectl package=alpine/k8s
          image: alpine/k8s:1.35.0@sha256:18bc02c1e0df04451f4f9194eb7b7341c1165da5495459b52f85f72fb9545032
          env:
            - name: RESOURCE_WAIT_TIMEOUT
              value: "600"
            - name: RESOURCE_CHECK_INTERVAL
              value: "5"
            - name: AUTH_WAIT_TIMEOUT
              value: "300"
            - name: AUTH_CHECK_INTERVAL
              value: "5"
          resources:
            limits:
              cpu: "100m"
              memory: "64Mi"
            requests:
              cpu: "50m"
              memory: "32Mi"
          command:
            - /bin/sh
            - -c
            - |
              set -e

              # Wait for authorization semaphore (cleanup-authorized ConfigMap)
              echo "Waiting for cleanup-authorized ConfigMap..."
              elapsed=0
              while [ "$$elapsed" -lt "$$AUTH_WAIT_TIMEOUT" ]; do
                if kubectl get configmap cleanup-authorized -n system-cleanup >/dev/null 2>&1; then
                  echo "Authorization semaphore detected. Proceeding with cleanup..."
                  break
                fi
                echo "Waiting for authorization... ($${elapsed}s/$${AUTH_WAIT_TIMEOUT}s)"
                sleep "$$AUTH_CHECK_INTERVAL"
                elapsed=$$((elapsed + AUTH_CHECK_INTERVAL))
              done

              if ! kubectl get configmap cleanup-authorized -n system-cleanup >/dev/null 2>&1; then
                echo "ERROR: Timed out waiting for cleanup-authorized ConfigMap."
                echo "Cleanup aborted for safety."
                exit 1
              fi

              echo "Processing PVCs..."
              kubectl get pvc --all-namespaces -o name || true

              # Delete all PVCs (non-blocking)
              echo "Deleting all PVCs..."
              kubectl delete pvc --all --all-namespaces --wait=false || true

              # Wait for PVCs to be deleted
              # Only remove kubernetes.io/pvc-protection (known safe)
              # All other finalizers are preserved for cloud/CSI cleanup
              echo "Waiting for PVCs to be deleted..."
              elapsed=0
              while [ "$$elapsed" -lt "$$RESOURCE_WAIT_TIMEOUT" ]; do
                remaining=$$(kubectl get pvc --all-namespaces --no-headers 2>/dev/null | wc -l | tr -d ' ')
                if [ "$$remaining" -eq 0 ]; then
                  echo "All PVCs deleted"
                  break
                fi

                # Check for stuck PVCs and remove only the protection finalizer
                for pvc in $$(kubectl get pvc --all-namespaces -o json | jq -r '.items[] | select(.metadata.deletionTimestamp != null) | "\(.metadata.namespace)/\(.metadata.name)"'); do
                  ns=$$(echo "$$pvc" | cut -d'/' -f1)
                  name=$$(echo "$$pvc" | cut -d'/' -f2)
                  
                  # Get current finalizers and filter out pvc-protection (atomic operation)
                  current=$$(kubectl get pvc "$$name" -n "$$ns" -o json 2>/dev/null)
                  if [ -z "$$current" ]; then
                    continue  # PVC already deleted
                  fi
                  
                  has_protection=$$(echo "$$current" | jq -r '.metadata.finalizers // [] | any(. == "kubernetes.io/pvc-protection")')
                  if [ "$$has_protection" = "true" ]; then
                    echo "PVC $$ns/$$name - removing protection finalizer"
                    new_finalizers=$$(echo "$$current" | jq -c '[.metadata.finalizers[] | select(. != "kubernetes.io/pvc-protection")]')
                    kubectl patch pvc "$$name" -n "$$ns" --type=merge -p="{\"metadata\":{\"finalizers\":$$new_finalizers}}" 2>/dev/null || true
                  else
                    echo "PVC $$ns/$$name waiting for controller cleanup..."
                  fi
                done

                echo "Still waiting for $$remaining PVCs to be deleted..."
                sleep "$$RESOURCE_CHECK_INTERVAL"
                elapsed=$$((elapsed + RESOURCE_CHECK_INTERVAL))
              done

              # Process PVs
              echo "Processing PVs..."
              kubectl get pv -o name || true

              # Delete all PVs (non-blocking)
              echo "Deleting all PVs..."
              for pv in $$(kubectl get pv -o name); do
                kubectl delete "$$pv" --wait=false || true
              done

              # Wait for PVs to be deleted
              # Only remove kubernetes.io/pv-protection (known safe)
              # All other finalizers are preserved for cloud/CSI cleanup
              echo "Waiting for PVs to be deleted..."
              elapsed=0
              while [ "$$elapsed" -lt "$$RESOURCE_WAIT_TIMEOUT" ]; do
                remaining=$$(kubectl get pv --no-headers 2>/dev/null | wc -l | tr -d ' ')
                if [ "$$remaining" -eq 0 ]; then
                  echo "All PVs deleted"
                  break
                fi

                # Check for stuck PVs and remove only the protection finalizer
                for pv in $$(kubectl get pv -o json | jq -r '.items[] | select(.metadata.deletionTimestamp != null) | .metadata.name'); do
                  # Get current finalizers and filter out pv-protection (atomic operation)
                  current=$$(kubectl get pv "$$pv" -o json 2>/dev/null)
                  if [ -z "$$current" ]; then
                    continue  # PV already deleted
                  fi
                  
                  has_protection=$$(echo "$$current" | jq -r '.metadata.finalizers // [] | any(. == "kubernetes.io/pv-protection")')
                  if [ "$$has_protection" = "true" ]; then
                    echo "PV $$pv - removing protection finalizer"
                    new_finalizers=$$(echo "$$current" | jq -c '[.metadata.finalizers[] | select(. != "kubernetes.io/pv-protection")]')
                    kubectl patch pv "$$pv" --type=merge -p="{\"metadata\":{\"finalizers\":$$new_finalizers}}" 2>/dev/null || true
                  else
                    echo "PV $$pv waiting for controller cleanup..."
                  fi
                done

                echo "Still waiting for $$remaining PVs to be deleted..."
                sleep "$$RESOURCE_CHECK_INTERVAL"
                elapsed=$$((elapsed + RESOURCE_CHECK_INTERVAL))
              done

              # Final verification
              echo "Verifying cleanup..."
              remaining_pvcs=$$(kubectl get pvc --all-namespaces --no-headers 2>/dev/null | wc -l | tr -d ' ')
              remaining_pvs=$$(kubectl get pv --no-headers 2>/dev/null | wc -l | tr -d ' ')
              if [ "$$remaining_pvcs" -gt 0 ] || [ "$$remaining_pvs" -gt 0 ]; then
                echo "ERROR: Cleanup incomplete - $$remaining_pvcs PVCs and $$remaining_pvs PVs remaining"
                echo "Remaining resources:"
                kubectl get pvc --all-namespaces 2>/dev/null || true
                kubectl get pv 2>/dev/null || true
                exit 1
              fi
              echo "PVC cleanup completed successfully"
